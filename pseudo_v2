//notes : under this pseudo code, the hotstuff information is mapped to Antelope concepts :
b_leaf (becomes) -> block_header_state.id
b_lock (becomes) -> finalizer_safety_information.locked_block_ref
b_exec (becomes) -> block proposal refered to by block_header_state_core.last_final_block_height
v_height (becomes) -> finalizer_safety_information.last_vote_block_ref
high_qc (becomes) -> block proposal refered to by block_header_state_core.last_qc_block_height

//todo : complete unification by merging the proposal_store with fork database

//structures

struct finalizer_authority {
	bls_public_key  		key;
	weight  				uint32_t;
}

struct finalizer_policy {
	
	finalizer_authority[] 	finalizers;

	uint32_t 				weight_quorum_threshold;

}

struct finalizer_safety_information{


	sha256[] 					last_vote_time_range;

	sha256 						last_vote_block_ref; //v_height under hotstuff
	sha256 						locked_block_ref; //b_lock under hotstuff

	bool 						is_last_vote_strong;

	bool 						recovery_mode; //todo : discuss


}

struct block_header_state_core {
	
	uint32_t					last_final_block_height; //b_exec under hotstuff
	std::optional<uint32_t>		final_on_strong_qc_block_height;
	std::optional<uint32_t>		last_qc_block_height; //high_qc under hotstuff

	block_header_state_core next(uint32_t last_qc_block_height, bool is_last_qc_strong){
		 
		 // no state change if last_qc_block_height is the same
	    if( last_qc_block_height == this->last_qc_block_height ) {
	       return {*this};
	    }

	    EOS_ASSERT( last_qc_block_height > this->last_qc_block_height, block_validate_exception, "new last_qc_block_height must be greater than old last_qc_block_height" );

	    auto old_last_qc_block_height = this->last_qc_block_height;
	    auto old_final_on_strong_qc_block_height = this->final_on_strong_qc_block_height;

	    block_header_state_core result{*this};

	    if( is_last_qc_strong ) {
	       // last QC is strong. We can progress forward.

	       // block with old final_on_strong_qc_block_height becomes irreversible
	       if( old_final_on_strong_qc_block_height.has_value() ) {

	       	  //old commit

	          result.last_final_block_height = *old_final_on_strong_qc_block_height;
	       }

	       // next block which can become irreversible is the block with
	       // old last_qc_block_height
	       if( old_last_qc_block_height.has_value() ) {
	          result.final_on_strong_qc_block_height = *old_last_qc_block_height;
	       }
	    } else {
	       // new final_on_strong_qc_block_height should not be present
	       result.final_on_strong_qc_block_height.reset();

	       // new last_final_block_height should be the same as the old last_final_block_height
	    }

	    // new last_qc_block_height is always the input last_qc_block_height.
	    result.last_qc_block_height = last_qc_block_height;

	    return result;

	}

}

struct block_header_state {
	
	//existing block_header_state members

	sha256						id; //b_leaf under hotstuff

	[...] //other existing block_header_state members

	//new additions

	sha256 						finalizer_digest;
	block_header_state_core 	core;
	incremental_block_mtree		proposal_mtree;
	incremental_block_mtree		finality_mtree;

	uint32_t					policy_generation;
	
}

using quorum_certificate = std::variant(pending_quorum_certificate, valid_quorum_certificate);

struct block_context {
	
	block_header_state 				bhs;
	finalizer_policy 				fp;

	quorum_certificate				qc; //current quorum_certificate, can be pending_quorum_certificate or valid_quorum_certificate

	uint64_t id() const {return bhs->id;}
	uint64_t get_height() const {return block_header::num_from_id(bhs->id);}

}

struct valid_quorum_certificate {
	hs_bitset 				strong_bitset;
	optional<hs_bitset> 	weak_bitset; //omitted if strong qc
	bls_signature 			signature; //set to strong_signature if strong qc, set to strong_signature + weak_signature if weak qc
	
	//constructor used for strong qc
	valid_quorum_certificate(hs_bitset b, bls_signature s) : 
	strong_bitset(b),
	signature(s)
	{}
	
	//constructor used for weak qc
	valid_quorum_certificate(hs_bitset sb, hs_bitset wb,  bls_signature s) :
	strong_bitset(sb),
	weak_bitset(wb),
	signature(s)
	{}

}

struct pending_quorum_certificate {

	hs_bitset 		strong_bitset;
	bls_signature 	strong_signature;
	hs_bitset 		weak_bitset;
	bls_signature 	weak_signature;

	valid_quorum_certificate to_valid() { 
		
		//collapse the pending_quorum_certificate into a valid_quorum_certificate

		if (!is_valid()) throw exception; //can't convert to valid qc if qc is invalid

		if (is_strong()) return {strong_bitset, strong_signature}; //strong qc
		else return {strong_bitset, weak_bitset, strong_signature + weak_signature }; //weak qc

	};

	bool strong_quorum_met(){

		[...] //abstracted, returns true if a strong quorum is met, false otherwise

	}

	bool weak_quorum_met(){

		[...] //abstracted, returns true if a weak quorum is met, false otherwise

	}

}

struct hs_vote_message {
	block_id_type   block_id; //temporary, probably not needed later
	sha256          proposal_digest; //proposal digest
	bls_public_key  finalizer_key;
	bls_signature   sig;
	bool 			weak; //indicate if vote is weak, strong otherwise
};


//added as a block_header extension before signing
struct hotstuff_header_extension {
	uint32_t					last_qc_block_height;
	bool						is_last_qc_strong;
}

//added as a block extension before broadcast
struct hotstuff_block_extension {
	valid_quorum_certificate 	qc;
}

//this structure holds the required information and methods for the Hotstuff algorithm. It is derived from a block and block_header content, notably extensions 
struct hs_proposal {
	
	//may not exist in final implementation, subject to change 

	block_id_type 						block_id; //computed, to be replaced with proposal_digest eventually

	uint32_t 							get_height(); //from block_id
	block_timestamp_type 				timestamp; //from block header

	//qc specific information

	uint32_t							last_qc_block_height; //from block header extension
	bool 								is_last_qc_strong; //from block header extension

	valid_quorum_certificate		 	qc; //from block extension

};

struct signed_block {

	[...] //existing signed_block members

}

//helper functions

bool is_qc_signature_valid(uint32_t finalizer_policy_generation, quorum_certificate qc) { 

	//verify that the qc signatures are valid according to current finalizer_policy_generation

	[...] //abstracted, return true if signature is valid, false otherwise

}

uint32_t calculate_weights(uint32_t finalizer_policy_generation, hs_bitset bitset){
	
	//calculate the total weight representation contained in the bitset, using the applicable finalizer_policy_generation

	[...] //abstracted, return the sum of all finalizer weights represented in the bitset where the bit is set to true

}

bool is_qc_strong(uint32_t fpg, valid_quorum_certificate qc, block_context& bc) {
	if (!is_qc_signature_valid(fpg, qc)) return false;
	if (calculate_weights(fpg, qc.strong_bitset) >= bc.fp.quorum_threshold) return true;
	else return false;
}

bool is_qc_weak(uint32_t finalizer_policy_generation, valid_quorum_certificate qc, block_context& bc) { 
	if (!is_qc_signature_valid(finalizer_policy_generation, qc)) return false;
	if (calculate_weights(fpg, qc.strong_bitset) + calculate_weights(fpg, qc.weak_bitset) >= bc.fp.quorum_threshold) return true;
	else return false;
}

//not currently used
sha256 get_proposal_digest(block_header_state bhs, signed_block p, bool weak){

	//provide a proposal digest with sufficient commitments for a light client to construct proofs of finality and inclusion
	//todo : determine require commitments and complete digest function
	
	//note : interface is probably too wide, but serves to illustrate that the proposal digest is generated from elements from the state and elements from the signed block

	//temporary implementation (insufficient for IBC but sufficient for internal Hotstuff)

	sha256 digest = p.block_id;

	if (weak) digest = hash(digest, "_WEAK"); //if weak is set to true, concatenate desambiguator
	return digest;

}

quorum_certificate get_qc(uint32_t block_height){
	
	[...] //abstracted, fetch qc by height from internal qc store, for the branch tracked by block_header_state

	return qc;

}

hotstuff_header_extension get_hotstuff_header_extension(block_context& bc){
	valid_quorum_certificate qc = get_qc(bc.bhs.core.last_qc_block_height, bc.id());
	bool strong = is_qc_strong(qc, bc);
	return {bc.bhs.core.last_qc_block_height, strong};
}

hotstuff_block_extension get_hotstuff_block_extension(block_context& bc){
	return {bc.qc.to_valid()};
}

//get finalizer info from storage, loaded on start, held in cache afterwards
void get_finalizer_info(bls_public_key key){
	
	[...] //abstracted, must get or create the finalizer safety info state for the given finalizer key

}

//write the finalizer info to disk to prevent accidental double-signing in case of crash + recovery 
void save_finalizer_info(bls_public_key key, finalizer_safety_information fsi){
	
	[...] //abstracted, must save the finalizer info associated to the key, and throw an exception / prevent additional signing if the write operation fails (?)

}

void add_proposal(hs_proposal p, block_context& bc){

	[...] //abstracted, add proposal to internal storage, indexed by block_id
	
}

block_context& get_context(block_id_type branch_head){

	[...] //abstracted, returns the branch_context identified by the head
	
}

hs_proposal get_proposal_by_id(sha256 block_id){

	[...] //abstracted, returns the hs_proposal identified by block_id
	
}

hs_proposal get_proposal_by_height(block_id_type branch_head, uint32_t qc_block_height){

	[...] //abstracted, returns the hs_proposal that has a qc at the specified qc_block_height on a specific branch, throw exception if no qc at block_height
	
}

bool extends(hs_proposal descendant, hs_proposal ancestor){
	
	[...] //abstracted, returns true if ancestor is a parent of descendant, false otherwise

}

void update_pending_qc(hs_vote_message v, block_context& bc){

	if (std::holds_alternative<valid_quorum_certificate>(bc.qc)) return; //can only update a pending qc

	pending_quorum_certificate pqc = std::get<pending_quorum_certificate>(bc.qc);

	//update the current pending_quorum_certificate with new vote information

	[...] //abstracted

	if (pqc.strong_quorum_met()){
		bc.bhs.core = bc.bhs.core.next(bc.get_height(), true);
	}
	else if (pqc.weak_quorum_met()){
		bc.bhs.core = bc.bhs.core.next(bc.get_height(), false);
	}

}

hs_proposal extract_proposal(signed_block sb, block_context& bc){
	
	hs_proposal p;	

	[...] //abstracted, see hs_proposal for how to retrieve the values

	return p;

}

enum VoteDecision {
	StrongVote,
	WeakVote,
	NoVote
}

VoteDecision decide_vote(hs_proposal p, finalizer_safety_information& fsi, block_context& bc){

	bool monotony_check = false;
	bool time_range_check = false;

	bool safety_check = false;
	bool liveness_check = false;

	b_phases = get_qc_chain(p);

	b2 = b_phases[2] //first phase, prepare
	b1 = b_phases[1] //second phase, precommit
	b = b_phases[0] //third phase, commit

	if (fsi.last_vote_block_ref != sha256.empty()){
		if (p.get_height() > get_proposal_by_id(fsi.last_vote_block_ref).get_height()){
			monotony_check = true;
		}
	}

	if (fsi.locked_block_ref != sha256.empty()){

		//Safety check : check if this proposal extends the proposal we're locked on
		if (extends(p, get_proposal_by_id(fsi.locked_block_ref)){
			safety_check = true;
		}

		//Liveness check : check if the height of this proposal's justification is higher than the height of the proposal I'm locked on. This allows restoration of liveness if a replica is locked on a stale proposal
		if (get_proposal_by_height(bc.id(), p.last_qc_block_height).get_height() >  get_proposal_by_id(fsi.locked_block_ref).get_height())){
			liveness_check = true;
		}

		//Time range check : check if the current proposal timestamp is greater than the last one we voted on
		if (p.timestamp > get_proposal_by_id(fsi.last_vote_block_ref).timestamp){
			time_range_check = true;
		}

	}
	else { 

		//if we're not locked on anything, means the protocol just activated or chain just launched and we can proceed
		liveness_check = true;
		safety_check = true;
		time_range_check = true; //can at least cast a weak vote in case of bootsrapping / escape hatch recovery
	}

	bool enough_for_strong_vote = monotony_check && (liveness_check || safety_check); 
	bool enough_for_weak_vote = time_range_check && (liveness_check || safety_check); 

	if (enough_for_strong_vote || enough_for_weak_vote){

		fsi.is_last_vote_strong = enough_for_strong_vote;
		fsi.last_vote_block_ref = p.block_id; //v_height

		if (b1.get_height() > get_proposal_by_id(fsi.locked_block_ref).get_height()){
			fsi.locked_block_ref = b1.block_id; //commit phase on b1
		}

		if (enough_for_strong_vote){
			fsi.last_vote_time_range = {fsi.last_vote_block_ref};
		}
		else {
			fsi.last_vote_time_range.push_back(fsi.last_vote_block_ref);
		}

	}
	
	if (enough_for_strong_vote) return VoteDecision::StrongVote;
	else if (enough_for_weak_vote) return VoteDecision::WeakVote;
	else return VoteDecision::NoVote;

}

//handlers

void on_signed_block_received(signed_block sb){

	[...] //verify if block can be linked to our fork database, throw exception if unable to ?, add to fork db

	block_context& bc = get_context(sb.previous);

	//block must carry a qc to make finality progress
	if (sb.qc != null){
		hs_proposal p = extract_proposal(sb, bc);

		on_proposal_received(p, bc);
	}
	
}

void on_proposal_received(hs_proposal p, block_context& bc){

	[...] //first stage proposal validation, throw exception if unable to

	add_proposal(p, bc); //adding proposal to internal store

	finalizers = [...] //abstracted, must return all finalizers for which we have the key and that are part of the active finalizer set

	//only relevant if I'm a finalizer
	if (finalizers.size()>0) {

		hs_vote_messages[] msgs;

		for (auto f : finalizers){

			finalizer_safety_information& fsi = get_finalizer_info(f);

			vote_decision vd = decide_vote(p, fsi, bc);

			if (vd == VoteDecision::StrongVote || vd == VoteDecision::WeakVote){
				save_finalizer_info(f, fsi); //save finalizer info to prevent double-voting
				hs_vote_message msg = [...] //create vote message
				msgs.push_back(msg);
			}


		}

		for (auto v : vote_messages){
			[...] //abstracted, broadcast vote message
		}
		
	}

	//relevant to all nodes
	if (p.last_qc_block_height > bc.bhs.last_qc_block_height) bc.bhs.core = bc.bhs.core.next(p.last_qc_block_height, p.is_last_qc_strong);

}

//when leader receives a vote on a proposal
void on_vote_received(hs_vote_message v){
	
	//check for duplicate or invalid vote, return in either case
	//abstracted [...]

	block_context& bc = get_context(v.block_id);

	am_i_leader = [...] //abstracted, must return true if I am the leader, false otherwise

	if(!am_i_leader) return;

	//only leader need to take action on votes

	update_pending_qc(v, bc); //update qc for this proposal

}

hs_proposal[] get_qc_chain(hs_proposal p, block_context& bc){
	
	b[];

	b[2] = get_proposal_by_height(bc.id(), p.last_qc_block_height); //first phase, prepare
	b[1] = get_proposal_by_height(bc.id(), b[2].last_qc_block_height); //second phase, precommit
	b[0] = get_proposal_by_height(bc.id(), b[1].last_qc_block_height); //third phase, commit

	return b;

}

//internal state

bool new_qc_since_last_block(block_context& bc){

	//tracks last qc that was included in a block. When a new block is about to be finalized, we check if our last_qc_block_height is higher than the previous_qc_block_height, and if so, we include the newer qc
	
	[...] //abstracted, returns true if a new QC has been reached since the last QC was sent out, false otherwise

}

//main algorithm entry point. This replaces on_beat() / create_proposal(), and it is now unified with existing systems 
{
	
	block_id_type branch_head = [...] //choose branch to extend from fork db;

	block_context& bc = get_context(branch_head);

	[...] //abstracted, create block header

	[...] //abstracted, sign block header

	[...] //abstracted, finalize

	if (new_qc_since_last_block(bc)) {

		//insert header extension
		header_extensions.push(get_hotstuff_header_extension(bc));

		//insert block extension if a new qc was created
		block_extensions.push(get_hotstuff_block_extension(bc));
		
	}

	[...] //broadcast signed_block. The signed_block is processed by the on_signed_block_received handler by other nodes on the network


}

